#This isa modified version of  
 # import the libraries

import numpy as np

from qiskit.circuit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.circuit import Reset
from qiskit.circuit.library.standard_gates import (IGate, U1Gate, U2Gate, U3Gate, XGate,
                                                   YGate, ZGate, HGate, SGate, SdgGate, TGate,
                                                   TdgGate, RXGate, RYGate, RZGate, CXGate,
                                                   CYGate, CZGate, CHGate, CRZGate, CU1Gate,
                                                   CU3Gate, SwapGate, RZZGate,
                                                   CCXGate, CSwapGate)
from qiskit.circuit.exceptions import CircuitError
from qiskit.util import deprecate_arguments


 # get user's input

@deprecate_arguments({'n_qubits': 'num_qubits'})
def random_circuit(num_qubits, depth, max_operands=2, measure=True,
                   conditional=True, reset=True, seed=None,
                   *, n_qubits=None):  
   

    one_q_ops = []
    one_q_ops=[eval(item) for item in input(
        '''Enter all the one-qubit gates you want to use. The options are:
        IGate   U1Gate  U2Gate  U3Gate  
        XGate   ZGate   HGate   SGate
        SdgGate TGate   TdgGate RXGate  
        RYGate  RZGate  
        
        '''
    ).split()]
    
    one_param = [U1Gate, RXGate, RYGate, RZGate, RZZGate, CU1Gate, CRZGate]
    two_param = [U2Gate]
    three_param = [U3Gate, CU3Gate]
    two_q_ops = [eval(item) for item in input(
        '''Enter all the two-qubits gates you want to use. The options are:
        CXGate   CYGate  CZGate  CHGate  
        CU1Gate  CU3Gate SwapGate RZZGate  
        '''
    ).split()]
    
 # build the circuit 

    qr = QuantumRegister(num_qubits, 'q')
    qc = QuantumCircuit(num_qubits)

        
    if measure or conditional:
        cr = ClassicalRegister(num_qubits, 'c')
        qc.add_register(cr)

    if reset:
        one_q_ops += [Reset]

    if seed is None:
        seed = np.random.randint(0, np.iinfo(np.int32).max)
    rng = np.random.default_rng(seed)

 # apply arbitrary random operations at every depth

    for _ in range(depth):
        remaining_qubits = list(range(num_qubits))
        while remaining_qubits:
            max_possible_operands = min(len(remaining_qubits), max_operands)
            num_operands = rng.choice(range(max_possible_operands)) + 1
            rng.shuffle(remaining_qubits)
            operands = remaining_qubits[:num_operands]
            remaining_qubits = [q for q in remaining_qubits if q not in operands]
            if num_operands == 1:
                operation = rng.choice(one_q_ops)
            elif num_operands == 2:
                operation = rng.choice(two_q_ops)
           
            if operation in one_param:
                num_angles = 1
            elif operation in two_param:
                num_angles = 2
            elif operation in three_param:
                num_angles = 3
            else:
                num_angles = 0
            angles = [rng.uniform(0, 2 * np.pi) for x in range(num_angles)]
            register_operands = [qr[i] for i in operands]
            op = operation(*angles)

            if conditional and rng.choice(range(10)) == 0:
                value = rng.integers(0, np.power(2, num_qubits))
                op.condition = (cr, value)

            qc.append(op, register_operands)

    if measure:
        qc.measure(qr, cr)

    return qc

 # call the function and print the circuit
    
num_qubits= int(input("Enter the number of qubits:"))
depth=int(input("Enter the depth of the circuit:"))
circ = random_circuit(num_qubits, depth)
circ.draw(output='mpl')
